{"version":3,"sources":["hooks/useWeb3.ts","config/constants/index.ts","hooks/useContract.ts","utils/translateTextHelpers.ts","hooks/useI18n.ts","utils/formatBalance.ts","hooks/useTokenBalance.ts","hooks/useAllowance.ts","utils/erc20.ts","hooks/useApprove.ts"],"names":["RPC_URL","getRpcUrl","httpProvider","Web3","providers","HttpProvider","timeout","useWeb3","ethereum","useWallet","refEth","useRef","useState","web3","setweb3","useEffect","current","farmsConfig","filter","farm","isCommunity","map","tokenSymbol","useContract","abi","address","contractOptions","eth","Contract","contract","setContract","useCake","getCakeAddress","erc20","useLifeContract","LIFE","useNFTFarmV2Contract","nftFarmV2","useNftLiteMarketplaceContract","NftLiteMarketplace","useLottery","lottery","getLotteryAddress","useMasterchef","masterChef","getMasterChefAddress","useSousChef","id","config","poolsConfig","find","pool","sousId","rawAbi","poolCategory","PoolCategory","BINANCE","sousChefBnb","sousChef","contractAddress","process","variableRegex","getTranslation","translations","translationId","fallback","foundTranslation","translation","data","stringId","translatedString","text","includes","stringToReplace","exec","fallbackValueAtIndex","split","replace","replaceDynamicString","useI18n","useContext","TranslationsContext","length","getBalanceNumber","balance","decimals","displayBalance","BigNumber","dividedBy","pow","toNumber","useTokenBalance","tokenAddress","setBalance","account","fastRefresh","useRefresh","a","getTokenBalance","res","fetchBalance","useNftAllowance","tokenContract","spenderAddress","dependency","allowance","setAllowance","methods","call","fetch","getContract","provider","getAllowance","lpContract","masterChefContract","options","userAddress","balanceOf","useNftApprove","useCallback","approve","ethers","constants","MaxUint256","send","from","tx","console","error"],"mappings":"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","file":"static/js/5.026ad898.chunk.js","sourcesContent":["import { useEffect, useState, useRef } from 'react'\r\nimport Web3 from 'web3'\r\nimport { HttpProviderOptions } from 'web3-core-helpers'\r\nimport { provider as ProviderType } from 'web3-core'\r\nimport { useWallet } from '@binance-chain/bsc-use-wallet'\r\nimport getRpcUrl from 'utils/getRpcUrl'\r\n\r\nconst RPC_URL = getRpcUrl()\r\nconst httpProvider = new Web3.providers.HttpProvider(RPC_URL, { timeout: 10000 } as HttpProviderOptions)\r\n\r\n/**\r\n * Provides a web3 instance using the provider provided by useWallet\r\n * with a fallback of an httpProver\r\n * Recreate web3 instance only if the ethereum provider change\r\n */\r\nconst useWeb3 = () => {\r\n  const { ethereum }: { ethereum: ProviderType } = useWallet()\r\n  const refEth = useRef(ethereum)\r\n  const [web3, setweb3] = useState(new Web3(ethereum || httpProvider))\r\n\r\n  useEffect(() => {\r\n    if (ethereum !== refEth.current) {\r\n      setweb3(new Web3(ethereum || httpProvider))\r\n      refEth.current = ethereum\r\n    }\r\n  }, [ethereum])\r\n\r\n  return web3\r\n}\r\n\r\nexport default useWeb3\r\n","import farmsConfig from './farms'\r\n\r\nconst communityFarms = farmsConfig.filter((farm) => farm.isCommunity).map((farm) => farm.tokenSymbol)\r\n\r\nexport { farmsConfig, communityFarms }\r\nexport { default as poolsConfig } from './pools'\r\nexport { default as ifosConfig } from './ifo'\r\n","import { useEffect, useState } from 'react'\r\nimport { AbiItem } from 'web3-utils'\r\nimport { ContractOptions } from 'web3-eth-contract'\r\nimport useWeb3 from 'hooks/useWeb3'\r\nimport { getMasterChefAddress, getCakeAddress, getLotteryAddress, getLotteryTicketAddress } from 'utils/addressHelpers'\r\nimport { poolsConfig } from 'config/constants'\r\nimport { PoolCategory } from 'config/constants/types'\r\nimport ifo from 'config/abi/ifo.json'\r\nimport erc20 from 'config/abi/erc20.json'\r\nimport nftFarm from 'config/abi/NftFarm.json'\r\nimport nftFarmV2 from 'config/abi/NftFarmV2.json'\r\nimport NftLiteMarketplace from 'config/abi/NftLiteMarketplace.json'\r\nimport nft from 'config/abi/NFT.json'\r\nimport LIFE from 'config/abi/LIFE.json'\r\nimport lottery from 'config/abi/lottery.json'\r\nimport lotteryTicket from 'config/abi/lotteryNft.json'\r\nimport masterChef from 'config/abi/masterchef.json'\r\nimport sousChef from 'config/abi/sousChef.json'\r\nimport sousChefBnb from 'config/abi/sousChefBnb.json'\r\n\r\nconst useContract = (abi: AbiItem, address: string, contractOptions?: ContractOptions) => {\r\n  const web3 = useWeb3()\r\n  const [contract, setContract] = useState(new web3.eth.Contract(abi, address, contractOptions))\r\n\r\n  useEffect(() => {\r\n    setContract(new web3.eth.Contract(abi, address, contractOptions))\r\n  }, [abi, address, contractOptions, web3])\r\n\r\n  return contract\r\n}\r\n\r\n/**\r\n * Helper hooks to get specific contracts (by ABI)\r\n */\r\n\r\nexport const useIfoContract = (address: string) => {\r\n  const ifoAbi = ifo as unknown as AbiItem\r\n  return useContract(ifoAbi, address)\r\n}\r\n\r\nexport const useERC20 = (address: string) => {\r\n  const erc20Abi = erc20 as unknown as AbiItem\r\n  return useContract(erc20Abi, address)\r\n}\r\n\r\nexport const useCake = () => {\r\n  return useERC20(getCakeAddress())\r\n}\r\n\r\nexport const useRabbitMintingFarm = (address: string) => {\r\n  const nftMintingFarmAbi = nftFarm as unknown as AbiItem\r\n  return useContract(nftMintingFarmAbi, address)\r\n}\r\n\r\nexport const usePancakeRabbits = (address: string) => {\r\n  const nftAbi = nft as unknown as AbiItem\r\n  return useContract(nftAbi, address)\r\n}\r\n\r\nexport const useLifeContract = (address: string) => {\r\n  const lifeAbi = LIFE as unknown as AbiItem\r\n  return useContract(lifeAbi, address)\r\n}\r\n\r\nexport const useNewNFTFarmContract = (address: string) => {\r\n  const nftFarmAbi = nftFarm as unknown as AbiItem\r\n  return useContract(nftFarmAbi, address)\r\n}\r\n\r\nexport const useNFTFarmV2Contract = (address: string) => {\r\n  const nftFarmAbi = nftFarmV2 as unknown as AbiItem\r\n  return useContract(nftFarmAbi, address)\r\n}\r\n\r\nexport const useNftLiteMarketplaceContract = (address: string) => {\r\n  const NftLiteMarketplaceAbi = NftLiteMarketplace as unknown as AbiItem\r\n  return useContract(NftLiteMarketplaceAbi, address)\r\n}\r\n\r\nexport const useLottery = () => {\r\n  const abi = lottery as unknown as AbiItem\r\n  return useContract(abi, getLotteryAddress())\r\n}\r\n\r\nexport const useLotteryTicket = () => {\r\n  const abi = lotteryTicket as unknown as AbiItem\r\n  return useContract(abi, getLotteryTicketAddress())\r\n}\r\n\r\nexport const useMasterchef = () => {\r\n  const abi = masterChef as unknown as AbiItem\r\n  return useContract(abi, getMasterChefAddress())\r\n}\r\n\r\nexport const useSousChef = (id) => {\r\n  const config = poolsConfig.find((pool) => pool.sousId === id)\r\n  const rawAbi = config.poolCategory === PoolCategory.BINANCE ? sousChefBnb : sousChef\r\n  const abi = rawAbi as unknown as AbiItem\r\n  return useContract(abi, config.contractAddress[process.env.REACT_APP_CHAIN_ID])\r\n}\r\n\r\nexport default useContract\r\n","import { useContext } from 'react'\r\nimport { TranslationsContext } from '../contexts/Localisation/translationsContext'\r\n\r\nconst variableRegex = /%(.*?)%/\r\n\r\nconst replaceDynamicString = (foundTranslation: string, fallback: string) => {\r\n  const stringToReplace = variableRegex.exec(foundTranslation)[0]\r\n  // const indexToReplace = foundTranslation.split(' ').indexOf(stringToReplace)\r\n  const fallbackValueAtIndex = fallback.split(' ')[0]\r\n  return foundTranslation.replace(stringToReplace, fallbackValueAtIndex)\r\n}\r\n\r\nexport const getTranslation = (translations: Array<any>, translationId: number, fallback: string) => {\r\n  const foundTranslation = translations.find((translation) => {\r\n    return translation.data.stringId === translationId\r\n  })\r\n  if (foundTranslation) {\r\n    const translatedString = foundTranslation.data.text\r\n    const includesVariable = translatedString.includes('%')\r\n    if (includesVariable) {\r\n      return replaceDynamicString(translatedString, fallback)\r\n    }\r\n    return translatedString\r\n  }\r\n  return fallback\r\n}\r\n\r\n// TODO: Replace instances where this is called directly with the \"useI18n\" hook.\r\n// Using this directly can lead to errors because \"useContext\" is not preserved between renders\r\n// @see https://reactjs.org/docs/hooks-rules.html\r\nexport const TranslateString = (translationId: number, fallback: string) => {\r\n  const { translations } = useContext(TranslationsContext)\r\n  if (translations[0] === 'error') {\r\n    return fallback\r\n  }\r\n  if (translations.length > 0) {\r\n    return getTranslation(translations, translationId, fallback)\r\n  }\r\n  return fallback\r\n}\r\n","import { useContext } from 'react'\r\nimport { TranslationsContext } from '../contexts/Localisation/translationsContext'\r\nimport { getTranslation } from '../utils/translateTextHelpers'\r\n\r\nconst useI18n = () => {\r\n  const { translations } = useContext(TranslationsContext)\r\n\r\n  return (translationId: number, fallback: string) => {\r\n    if (translations[0] === 'error') {\r\n      return fallback\r\n    }\r\n    if (translations.length > 0) {\r\n      return getTranslation(translations, translationId, fallback)\r\n    }\r\n    return fallback\r\n  }\r\n}\r\n\r\nexport default useI18n\r\n","import BigNumber from 'bignumber.js'\r\n\r\nexport const getBalanceNumber = (balance: BigNumber, decimals = 18) => {\r\n  const displayBalance = new BigNumber(balance).dividedBy(new BigNumber(10).pow(decimals))\r\n  return displayBalance.toNumber()\r\n}\r\n\r\nexport const getFullDisplayBalance = (balance: BigNumber, decimals = 18) => {\r\n  return balance.dividedBy(new BigNumber(10).pow(decimals)).toFixed()\r\n}\r\n","import { useEffect, useState } from 'react'\r\nimport BigNumber from 'bignumber.js'\r\nimport { useWallet } from '@binance-chain/bsc-use-wallet'\r\nimport { provider } from 'web3-core'\r\nimport cakeABI from 'config/abi/cake.json'\r\nimport { getContract } from 'utils/web3'\r\nimport { getTokenBalance } from 'utils/erc20'\r\nimport { getCakeAddress } from 'utils/addressHelpers'\r\nimport useRefresh from './useRefresh'\r\n\r\nconst useTokenBalance = (tokenAddress: string) => {\r\n  const [balance, setBalance] = useState(new BigNumber(0))\r\n  const { account, ethereum }: { account: string; ethereum: provider } = useWallet()\r\n  const { fastRefresh } = useRefresh()\r\n\r\n  useEffect(() => {\r\n    const fetchBalance = async () => {\r\n      const res = await getTokenBalance(ethereum, tokenAddress, account)\r\n      setBalance(new BigNumber(res))\r\n    }\r\n\r\n    if (account && ethereum) {\r\n      fetchBalance()\r\n    }\r\n  }, [account, ethereum, tokenAddress, fastRefresh])\r\n\r\n  return balance\r\n}\r\n\r\nexport const useTotalSupply = () => {\r\n  const { slowRefresh } = useRefresh()\r\n  const [totalSupply, setTotalSupply] = useState<BigNumber>()\r\n\r\n  useEffect(() => {\r\n    async function fetchTotalSupply() {\r\n      const cakeContract = getContract(cakeABI, getCakeAddress())\r\n      const supply = await cakeContract.methods.totalSupply().call()\r\n      setTotalSupply(new BigNumber(supply))\r\n    }\r\n\r\n    fetchTotalSupply()\r\n  }, [slowRefresh])\r\n\r\n  return totalSupply\r\n}\r\n\r\nexport const useBurnedBalance = (tokenAddress: string) => {\r\n  const [balance, setBalance] = useState(new BigNumber(0))\r\n  const { slowRefresh } = useRefresh()\r\n\r\n  useEffect(() => {\r\n    const fetchBalance = async () => {\r\n      const cakeContract = getContract(cakeABI, getCakeAddress())\r\n      const bal = await cakeContract.methods.balanceOf('0x000000000000000000000000000000000000dEaD').call()\r\n      setBalance(new BigNumber(bal))\r\n    }\r\n\r\n    fetchBalance()\r\n  }, [tokenAddress, slowRefresh])\r\n\r\n  return balance\r\n}\r\n\r\nexport default useTokenBalance\r\n","import { useEffect, useState } from 'react'\r\nimport BigNumber from 'bignumber.js'\r\nimport { useWallet } from '@binance-chain/bsc-use-wallet'\r\nimport { Contract } from 'web3-eth-contract'\r\nimport { useCake, useLottery } from './useContract'\r\nimport { getAllowance } from '../utils/erc20'\r\n\r\n// Retrieve lottery allowance\r\nexport const useLotteryAllowance = () => {\r\n  const [allowance, setAllowance] = useState(new BigNumber(0))\r\n  const { account }: { account: string } = useWallet()\r\n  const lotteryContract = useLottery()\r\n  const cakeContract = useCake()\r\n\r\n  useEffect(() => {\r\n    const fetchAllowance = async () => {\r\n      const res = await getAllowance(cakeContract, lotteryContract, account)\r\n      setAllowance(new BigNumber(res))\r\n    }\r\n\r\n    if (account && cakeContract && cakeContract) {\r\n      fetchAllowance()\r\n    }\r\n    const refreshInterval = setInterval(fetchAllowance, 10000)\r\n    return () => clearInterval(refreshInterval)\r\n  }, [account, cakeContract, lotteryContract])\r\n\r\n  return allowance\r\n}\r\n\r\n// Retrieve IFO allowance\r\nexport const useIfoAllowance = (tokenContract: Contract, spenderAddress: string, dependency?: any) => {\r\n  const { account }: { account: string } = useWallet()\r\n  const [allowance, setAllowance] = useState(null)\r\n\r\n  useEffect(() => {\r\n    const fetch = async () => {\r\n      try {\r\n        const res = await tokenContract.methods.allowance(account, spenderAddress).call()\r\n        setAllowance(new BigNumber(res))\r\n      } catch (e) {\r\n        setAllowance(null)\r\n      }\r\n    }\r\n    fetch()\r\n  }, [account, spenderAddress, tokenContract, dependency])\r\n\r\n  return allowance\r\n}\r\n\r\n// Retrieve NFT allowance\r\nexport const useNftAllowance = (tokenContract: Contract, spenderAddress: string, dependency?: any) => {\r\n  const { account }: { account: string } = useWallet()\r\n  const [allowance, setAllowance] = useState(null)\r\n\r\n  useEffect(() => {\r\n    const fetch = async () => {\r\n      try {\r\n        const res = await tokenContract.methods.allowance(account, spenderAddress).call()\r\n        setAllowance(new BigNumber(res))\r\n      } catch (e) {\r\n        setAllowance(null)\r\n      }\r\n    }\r\n    fetch()\r\n  }, [account, spenderAddress, tokenContract, dependency])\r\n\r\n  return allowance\r\n}\r\n","import Web3 from 'web3'\r\nimport { provider as ProviderType } from 'web3-core'\r\nimport { Contract } from 'web3-eth-contract'\r\nimport { AbiItem } from 'web3-utils'\r\nimport erc20 from 'config/abi/erc20.json'\r\n\r\nexport const getContract = (provider: ProviderType, address: string) => {\r\n  const web3 = new Web3(provider)\r\n  const contract = new web3.eth.Contract(erc20 as unknown as AbiItem, address)\r\n  return contract\r\n}\r\n\r\nexport const getAllowance = async (\r\n  lpContract: Contract,\r\n  masterChefContract: Contract,\r\n  account: string,\r\n): Promise<string> => {\r\n  try {\r\n    const allowance: string = await lpContract.methods.allowance(account, masterChefContract.options.address).call()\r\n    return allowance\r\n  } catch (e) {\r\n    return '0'\r\n  }\r\n}\r\n\r\nexport const getTokenBalance = async (\r\n  provider: ProviderType,\r\n  tokenAddress: string,\r\n  userAddress: string,\r\n): Promise<string> => {\r\n  const contract = getContract(provider, tokenAddress)\r\n  try {\r\n    const balance: string = await contract.methods.balanceOf(userAddress).call()\r\n    return balance\r\n  } catch (e) {\r\n    return '0'\r\n  }\r\n}\r\n","import { useCallback } from 'react'\r\nimport { useWallet } from '@binance-chain/bsc-use-wallet'\r\nimport { Contract } from 'web3-eth-contract'\r\nimport { ethers } from 'ethers'\r\nimport { useDispatch } from 'react-redux'\r\nimport { updateUserAllowance, fetchFarmUserDataAsync } from 'state/actions'\r\nimport { approve } from 'utils/callHelpers'\r\nimport { useMasterchef, useCake, useSousChef, useLottery } from './useContract'\r\n\r\n// Approve a Farm\r\nexport const useApprove = (lpContract: Contract) => {\r\n  const dispatch = useDispatch()\r\n  const { account }: { account: string } = useWallet()\r\n  const masterChefContract = useMasterchef()\r\n\r\n  const handleApprove = useCallback(async () => {\r\n    try {\r\n      const tx = await approve(lpContract, masterChefContract, account)\r\n      dispatch(fetchFarmUserDataAsync(account))\r\n      return tx\r\n    } catch (e) {\r\n      return false\r\n    }\r\n  }, [account, dispatch, lpContract, masterChefContract])\r\n\r\n  return { onApprove: handleApprove }\r\n}\r\n\r\n// Approve a Pool\r\nexport const useSousApprove = (lpContract: Contract, sousId) => {\r\n  const dispatch = useDispatch()\r\n  const { account }: { account: string } = useWallet()\r\n  const sousChefContract = useSousChef(sousId)\r\n\r\n  const handleApprove = useCallback(async () => {\r\n    try {\r\n      const tx = await approve(lpContract, sousChefContract, account)\r\n      dispatch(updateUserAllowance(sousId, account))\r\n      return tx\r\n    } catch (e) {\r\n      return false\r\n    }\r\n  }, [account, dispatch, lpContract, sousChefContract, sousId])\r\n\r\n  return { onApprove: handleApprove }\r\n}\r\n\r\n// Approve the lottery\r\nexport const useLotteryApprove = () => {\r\n  const { account }: { account: string } = useWallet()\r\n  const cakeContract = useCake()\r\n  const lotteryContract = useLottery()\r\n\r\n  const handleApprove = useCallback(async () => {\r\n    try {\r\n      const tx = await approve(cakeContract, lotteryContract, account)\r\n      return tx\r\n    } catch (e) {\r\n      return false\r\n    }\r\n  }, [account, cakeContract, lotteryContract])\r\n\r\n  return { onApprove: handleApprove }\r\n}\r\n\r\n// Approve an IFO\r\nexport const useIfoApprove = (tokenContract: Contract, spenderAddress: string) => {\r\n  const { account } = useWallet()\r\n  const onApprove = useCallback(async () => {\r\n    try {\r\n      const tx = await tokenContract.methods\r\n        .approve(spenderAddress, ethers.constants.MaxUint256)\r\n        .send({ from: account })\r\n      return tx\r\n    } catch {\r\n      return false\r\n    }\r\n  }, [account, spenderAddress, tokenContract])\r\n\r\n  return onApprove\r\n}\r\n\r\n// Approve an NFT\r\nexport const useNftApprove = (tokenContract: Contract, spenderAddress: string) => {\r\n  const { account } = useWallet()\r\n  const onApprove = useCallback(async () => {\r\n    try {\r\n      const tx = await tokenContract.methods\r\n        .approve(spenderAddress, ethers.constants.MaxUint256)\r\n        .send({ from: account })\r\n      return tx\r\n    } catch (error) {\r\n      console.error(\"error\", error);\r\n      return false\r\n    }\r\n  }, [account, spenderAddress, tokenContract])\r\n\r\n  return onApprove\r\n}\r\n"],"sourceRoot":""}